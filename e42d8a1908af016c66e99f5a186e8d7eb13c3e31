{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ad0747ea_6daf1e73",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-12-13T14:42:22Z",
      "side": 1,
      "message": "Adding Mathew to the review, and marking -2 before this gets in - the consequences of this AFAIU is that we\u0027re making the HIDDEN_API_* values in Application more or less public, at least SystemApi, when they are today just internal to the framework.\n\nMaybe that\u0027s OK, and we\u0027re ready to promote those values to external users such as studion, but I\u0027m flagging it in case it\u0027s not clear for everyone.",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc112d18_b84511b6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-12-13T16:55:04Z",
      "side": 1,
      "message": "This is limited to debuggable where you can mostly turn hiddenapi off in other ways. Also these extensions are not really a part of any api and are meant (and only really available) for tools that reach deep into the runtime and are expected to have far deeper knowledge of internals than real apps.\n\nIf you wish it would be pretty easy to change this to not rely on knowing the values (basically just give values in the description text and translated instead of cast) but this seemed easier given that studio would be able to easily check them for every release and the entire point of this is to quiet down some logspam so failure isn\u0027t disastrous.",
      "parentUuid": "ad0747ea_6daf1e73",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "238b4066_78006439",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1010681
      },
      "writtenOn": "2020-12-14T10:07:14Z",
      "side": 1,
      "message": "As I said on the thread, I\u0027d rather not expose this. The problem with this approach is that is allows hidden API access to the whole app, meaning app developers will miss other usages in their app, so therefore miss bugs elsewhere.\n\nCan we instead create a parallel of VMDebug.allowHiddenApiReflectionFrom() which allows hidden API access from a *single class*? That can then be called before the debugger redefines any class, keeping the scope of the change to just what\u0027s needed.",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc36a295_be72773b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-12-14T15:32:54Z",
      "side": 1,
      "message": "AIUI The accesses being warned are from relinking the class, there is no reflection and no similar way to know where we are coming from like with reflection. The idea for this then was to allow studio to quickly toggle this off and on as it does its setup. This is the same thing art itself does btw https://cs.android.com/android/platform/superproject/+/master:art/runtime/well_known_classes.cc;l\u003d331;bpv\u003d1;bpt\u003d1\n\nAs long as studio is relatively quick there shouldn\u0027t be much danger if missing major hiddenapi use.",
      "parentUuid": "238b4066_78006439",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "431d372c_7242e041",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1010681
      },
      "writtenOn": "2020-12-14T16:37:19Z",
      "side": 1,
      "message": "Does the linker not know *which* class it is linking?\n\nIf the intent is to scope it like in well_known_classes, can that be reflected in the API, perhaps by exposing something like ScopedHiddenApiEnforcementPolicySetting ?\n\nIf the setting is reset once the class definition is complete that is much better, but that\u0027s not reflected in this CL in the API structure or even the docs.",
      "parentUuid": "bc36a295_be72773b",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "82b0efd3_af79369b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-12-14T16:46:11Z",
      "side": 1,
      "message": "There is no good way to restore the hiddenapi state of a class. Permanently turning off all hiddenapi messages for several major classes such as Thread seems even worse TBH.\n\nJVMTI extension entry-points can be a single function pointer. There is nothing else (such as structs) that can be exposed. This prevents us from doing something like ScopedHidden\u003cetc\u003e unless we want to be passing around thunks. I\u0027d rather stick with this which is pretty similar to other JVMTI functions and (like with other places) rely on the agent authors to know what they are doing.\n\nAs I said the API structure is restricted by what can be used with the JVMTI extension API so get/set is pretty much the best we can do. I can add a recommendation to the description text if you want saying to do this. Honestly though this and all other JVMTI APIs require and assume that the user has pretty deep knowledge of internals and can be trusted to know what they are doing. This isn\u0027t something that some random library author will stumble across and try to use.",
      "parentUuid": "431d372c_7242e041",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "301f0b32_08943b56",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-12-14T16:54:05Z",
      "side": 1,
      "message": "That this is an API which requires deep knowledge of internals, I think we all agree. But that doesn\u0027t change the fact as soon as it\u0027s out there it\u0027s a public/system API we need to commit to.",
      "parentUuid": "82b0efd3_af79369b",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fd61ae60_6c7057d9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-12-14T17:03:39Z",
      "side": 1,
      "message": "That hasn\u0027t really been true so far with JVMTI related things. Given they are so deeply tied with the internals of the runtime and are available only for debugging tools AIUI we\u0027ve not really considered it a true public-api or even a system-api.",
      "parentUuid": "301f0b32_08943b56",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3cacacf1_ac10af31",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-12-14T17:06:43Z",
      "side": 1,
      "message": "Have we exposed fields from the framework?",
      "parentUuid": "fd61ae60_6c7057d9",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b50f163e_927c10e1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-12-14T17:33:23Z",
      "side": 1,
      "message": "JVMTI is entirely self-contained and baked into its design is having a large number of optional apis that agents need to check for and only use when availible.",
      "parentUuid": "3cacacf1_ac10af31",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ffb9087b_3d206afe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-12-14T17:36:13Z",
      "side": 1,
      "message": "Yes, I understand that. However, in this CL we\u0027re exposing a policy which is internal to the Android platform, and which the compat team owns. Not ART.",
      "parentUuid": "b50f163e_927c10e1",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b874e8f5_344e367c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-12-14T19:25:05Z",
      "side": 1,
      "message": "@acleung for comment.\n\nTo be honest I don\u0027t think the decision calculus changes regardless of whether its art or compat.",
      "parentUuid": "ffb9087b_3d206afe",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f8f37cd7_3cdb7fa5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1080224
      },
      "writtenOn": "2020-12-14T19:33:12Z",
      "side": 1,
      "message": "Alex / Nicolas:\n\nI am not sure I am knowledgeable enough to answer the question at hand.\n\nMy intuition would lead to to think that this should not be exposed outside of ART / JVMTI since agents implies privileged control on a debuggable app.",
      "parentUuid": "b874e8f5_344e367c",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "05e802f9_f2c7c7c7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-12-14T20:29:29Z",
      "side": 1,
      "message": "\u003e To be honest I don\u0027t think the decision calculus changes regardless of whether its art or compat.\n\nThis is in response to self-contained. Anyway, I don\u0027t think this is something we need to debate here, as it seems we agree in this CL we\u0027re exposing this API outside of ART.",
      "parentUuid": "f8f37cd7_3cdb7fa5",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a966def6_a554f9fe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-12-14T22:38:15Z",
      "side": 1,
      "message": "@Mathewi, I realized I never really answered your question. The messages are coming from the class being re-verified for class-redefinition. As far as hiddenapi knows this is just a random class being verified but it tries to access (its own) hiddenapis. Normal linking doesn\u0027t cause this because the class doesn\u0027t exist yet. Because of how verification works the hiddenapi denials aren\u0027t serious but sending the state needed to know to ignore the warnings down would require major surgery.",
      "parentUuid": "05e802f9_f2c7c7c7",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b01fd474_7c5e8c2f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1010681
      },
      "writtenOn": "2020-12-15T13:02:12Z",
      "side": 1,
      "message": "Ok, lots to think about here ðŸ˜Š\n\nIIUC, you\u0027re saying that ignoring hidden API accesses *from* a particular class (as per allowHiddenApiReflectionFrom) is not feasible during linking?\n\nre: \"Permanently turning off all hiddenapi messages for several major classes such as Thread seems even worse TBH.\"\n\nIt depends if you mean hiddenapi messages *from* Thread or *to* thread. I was thinking that when redefining a class, we\u0027d allow all hiddenapi access *from* that class, but hiddenapi access *to* it would be unaffected. I think that\u0027s how the existing allowHiddenApiReflectionFrom works. If we\u0027re only redefining platform classes, all hidden API access from them is ok anyway. (Does the debugger do the same for app classes too?)\n\nI\u0027d prefer the change to be as tightly scoped as possible. e.g. we could add some new runtime state to suppress only linking API accesses. Could something like that work?",
      "parentUuid": "a966def6_a554f9fe",
      "revId": "e42d8a1908af016c66e99f5a186e8d7eb13c3e31",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}