{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9bf6a2ce_6ecf74ad",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1894735
      },
      "writtenOn": "2024-06-18T11:40:55Z",
      "side": 1,
      "message": "Thanks!",
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71cc2022_e434c857",
        "filename": "runtime/base/locks.cc",
        "patchSetId": 4
      },
      "lineNbr": 323,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2024-06-21T21:43:40Z",
      "side": 1,
      "message": "General comment: I think we should avoid introducing a new lock level for each of these. Each lock level costs us 8 bytes in the thread structure, plus time overhead in debug builds. IMO, we currently have way too many lock levels.\n\nI suspect this is never held concurrently with kCHALock, so the two could be merged?\n\nI started doing this in (unsubmitted) https://android-review.googlesource.com/c/platform/art/+/2726506/6/runtime/base/locks.cc",
      "range": {
        "startLine": 321,
        "startChar": 3,
        "endLine": 323,
        "endChar": 96
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "158dc08d_733085db",
        "filename": "runtime/base/locks.cc",
        "patchSetId": 4
      },
      "lineNbr": 323,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2024-06-24T13:22:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "71cc2022_e434c857",
      "range": {
        "startLine": 321,
        "startChar": 3,
        "endLine": 323,
        "endChar": 96
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "419992d2_948da1eb",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 4
      },
      "lineNbr": 443,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2024-06-21T21:43:40Z",
      "side": 1,
      "message": "Is there an issue with mutual exclusion on these? We now only hold a reader lock here, right? I don\u0027t understand the context sufficiently.",
      "range": {
        "startLine": 443,
        "startChar": 12,
        "endLine": 443,
        "endChar": 20
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2369d77_f176f0e0",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 4
      },
      "lineNbr": 443,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2024-06-24T13:22:39Z",
      "side": 1,
      "message": "Yes that\u0027s ok, only this place updates the entry. The reader lock is so that no one changes `method_code_map_`.",
      "parentUuid": "419992d2_948da1eb",
      "range": {
        "startLine": 443,
        "startChar": 12,
        "endLine": 443,
        "endChar": 20
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86c67520_9a52d422",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 4
      },
      "lineNbr": 907,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2024-06-21T21:43:40Z",
      "side": 1,
      "message": "Why does \"Reader\" suffice for writing the maps?",
      "range": {
        "startLine": 907,
        "startChar": 4,
        "endLine": 907,
        "endChar": 10
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5b629180_4aa7db6c",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 4
      },
      "lineNbr": 907,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2024-06-24T13:22:39Z",
      "side": 1,
      "message": "This is an in-place update of a entry in `method_code_map_`. That\u0027s ok here, we only want to protect from insertion/deletion in `method_code_map_`.",
      "parentUuid": "86c67520_9a52d422",
      "range": {
        "startLine": 907,
        "startChar": 4,
        "endLine": 907,
        "endChar": 10
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b27f877b_2c536e0e",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 4
      },
      "lineNbr": 907,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2024-07-01T22:59:23Z",
      "side": 1,
      "message": "So jit_mutator_lock_ protects the structure and the keys of the map, but not the values? But can\u0027t the values be concurrently replaced and read? So do we still have a data race on those?\n\nI\u0027m concerned both about potential C++ miscompilation and memory ordering. If these can happen concurrently, is there any guarantee that if we see an updated entry, the ArtMethod is visible?",
      "parentUuid": "5b629180_4aa7db6c",
      "range": {
        "startLine": 907,
        "startChar": 4,
        "endLine": 907,
        "endChar": 10
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "36298553_7ed2cc25",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 4
      },
      "lineNbr": 907,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2024-07-03T14:47:15Z",
      "side": 1,
      "message": "To be on the safe side, I\u0027ve moved it to a writer lock. We shouldn\u0027t get concurrent updates of this entry (making methods obsolete is a single threaded thing). On the other hand, this isn\u0027t performance sensitive to matter.",
      "parentUuid": "b27f877b_2c536e0e",
      "range": {
        "startLine": 907,
        "startChar": 4,
        "endLine": 907,
        "endChar": 10
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "324ffcc2_6f74dfbf",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 4
      },
      "lineNbr": 907,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2024-07-03T18:27:43Z",
      "side": 1,
      "message": "LGTM, but at least superficially, it looks to me like theree\u0027s another variant of this issue above. I should have pointed that out sooner.",
      "parentUuid": "36298553_7ed2cc25",
      "range": {
        "startLine": 907,
        "startChar": 4,
        "endLine": 907,
        "endChar": 10
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35a34f85_1bfd4c66",
        "filename": "runtime/jit/jit_code_cache.h",
        "patchSetId": 4
      },
      "lineNbr": 434,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2024-06-21T21:43:40Z",
      "side": 1,
      "message": "Deleting the mutator_lock_ requirement here is a drive-by cleanup? That\u0027s fine, but I want to make sure I\u0027m not missing something.",
      "range": {
        "startLine": 434,
        "startChar": 6,
        "endLine": 434,
        "endChar": 41
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c2957139_f16a90f8",
        "filename": "runtime/jit/jit_code_cache.h",
        "patchSetId": 4
      },
      "lineNbr": 434,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2024-06-24T13:22:39Z",
      "side": 1,
      "message": "Thanks for catching this. It should be safe to keep the requirement (as it should be always called with the mutator lock, even though we\u0027re not accessing the heap).",
      "parentUuid": "35a34f85_1bfd4c66",
      "range": {
        "startLine": 434,
        "startChar": 6,
        "endLine": 434,
        "endChar": 41
      },
      "revId": "0c8791dee66c10a708819750717d994034e916d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}