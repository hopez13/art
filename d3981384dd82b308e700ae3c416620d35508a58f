{
  "comments": [
    {
      "key": {
        "uuid": "5abd8e1c_55aba896",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 678,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-26T21:36:32Z",
      "side": 1,
      "message": "It now looks to me like these should stay as they were.",
      "range": {
        "startLine": 678,
        "startChar": 40,
        "endLine": 678,
        "endChar": 66
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a13a0d41_8ec369c6",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 678,
      "author": {
        "id": 1071150
      },
      "writtenOn": "2018-03-27T15:03:31Z",
      "side": 1,
      "message": "PS4 relaxes most access to cur_offset_.\n\nIn PS4, I think this needs to be seq_cst for the case when we are running with a sampling thread. The store here need to be visible when the sampling thread calls WriteBuf().\n\nPreviously, there was a seq_cst store in the constructor initializer values so not a material change.",
      "parentUuid": "5abd8e1c_55aba896",
      "range": {
        "startLine": 678,
        "startChar": 40,
        "endLine": 678,
        "endChar": 66
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17018f4b_8d5c0ad4",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 678,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-28T05:30:48Z",
      "side": 1,
      "message": "What do you think needs to be made visible? Seq_cst ensures that stores are made visible in a globally consistent order, and before any following seq_cst loads are performed. It would be really surprising to me if this needed seq_cst. If it\u0027s used to publish the preceding appends, then release makes sense. I\u0027ll have to look at it more carefully tomorrow.",
      "parentUuid": "a13a0d41_8ec369c6",
      "range": {
        "startLine": 678,
        "startChar": 40,
        "endLine": 678,
        "endChar": 66
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5585a80_bd947f48",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 678,
      "author": {
        "id": 1071150
      },
      "writtenOn": "2018-03-28T12:38:02Z",
      "side": 1,
      "message": "This was being conservative as there isn\u0027t an acquire to pair with the release in the current code and the code already had a seq_cst store to this field in the constructor.\n\nOn closer inspection, it looks okay to be relaxed here:\n\n1) In non-streaming mode, the cur_offset is updated by compare_exchange_weak in LogMethodTraceEvent.\n2) In non-streaming mode, it is updated after acquiring the streaming mutex.\n3) When we reach FinishTracing(), the caller has acquired and released the trace_lock_.",
      "parentUuid": "17018f4b_8d5c0ad4",
      "range": {
        "startLine": 678,
        "startChar": 40,
        "endLine": 678,
        "endChar": 66
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12e90bef_8becc27a",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 999,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-26T18:49:20Z",
      "side": 1,
      "message": "This looks like a speculative load used to implement what\u0027s effectively a fetch_add with overflow detection. If we need the acquire, we probably need it only for the overflow case. It\u0027s probably cheaper to put an atomic_thread_fence(memory_order_acquire) just in that branch. But see the other comment; I don\u0027t really understand what we need here.",
      "range": {
        "startLine": 999,
        "startChar": 4,
        "endLine": 999,
        "endChar": 61
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99cb31b4_6244c136",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 999,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-26T21:36:32Z",
      "side": 1,
      "message": "... and this should stay relaxed ...",
      "parentUuid": "12e90bef_8becc27a",
      "range": {
        "startLine": 999,
        "startChar": 4,
        "endLine": 999,
        "endChar": 61
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "721afc63_c7a8a1db",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 999,
      "author": {
        "id": 1071150
      },
      "writtenOn": "2018-03-27T15:03:31Z",
      "side": 1,
      "message": "Yes. The relaxed form boils down to ldxr/sdxr and the acq_rel form to ldaxr/stlxr. The former should suffice here.\n\nI\u0027m not sure what purpose the acquire fence would serve here.",
      "parentUuid": "99cb31b4_6244c136",
      "range": {
        "startLine": 999,
        "startChar": 4,
        "endLine": 999,
        "endChar": 61
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e2aba2b_aa1bf030",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 1006,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-26T21:36:32Z",
      "side": 1,
      "message": "... and this should become relaxed.\n\nAs should the stores in WriteToBuf, and FlushBuf, which I think should not race with anything, since everything appears to be lock-protected in streaming mode.",
      "range": {
        "startLine": 1006,
        "startChar": 72,
        "endLine": 1006,
        "endChar": 97
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f77dfa2f_2886b318",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 1006,
      "author": {
        "id": 1071150
      },
      "writtenOn": "2018-03-27T15:03:31Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2e2aba2b_aa1bf030",
      "range": {
        "startLine": 1006,
        "startChar": 72,
        "endLine": 1006,
        "endChar": 97
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6c33a595_b7f2b9c0",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 1048,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2018-03-26T21:44:00Z",
      "side": 1,
      "message": "There should really be some sort of explanation here for how/where these writes to buf_[old_offset] synchronize-with future reads.\n\nIt\u0027s completely non-obvious regardless of what trace_output_mode_ is.",
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4e452f3_a14599fb",
        "filename": "runtime/trace.cc",
        "patchSetId": 3
      },
      "lineNbr": 1048,
      "author": {
        "id": 1071150
      },
      "writtenOn": "2018-03-27T15:03:31Z",
      "side": 1,
      "message": "Comments added here, to the buf_ field, and to FinishTracing().",
      "parentUuid": "6c33a595_b7f2b9c0",
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "27c62b82_d18bdd8e",
        "filename": "runtime/trace.h",
        "patchSetId": 3
      },
      "lineNbr": 346,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-26T21:36:32Z",
      "side": 1,
      "message": "(Unless I\u0027m misunderstanding something) please add a comment:\nCur_offset_ is atomic to allow multiple writers to concurrently reserve space in the buffer. The newly written buffer contents are not read without some other form of thread synchronization, such as suspending all potential writers or acquiring *streaming_lock_. Reading cur_offset_ is thus never used to ensure visibility of any other objects, and all accesses are memory_order_relaxed.",
      "range": {
        "startLine": 346,
        "startChar": 2,
        "endLine": 346,
        "endChar": 22
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fd8d968c_7b5618bc",
        "filename": "runtime/trace.h",
        "patchSetId": 3
      },
      "lineNbr": 359,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-26T18:49:20Z",
      "side": 1,
      "message": "Do you understand the intended logic here?  I don\u0027t.\n\nIt seems like most users of cur_offset_ either hold streaming_lock, or could be made to hold it while accessing cur_offset_. And cur_offset is used in a way that seems to inherently require additional synchronization. cur_offset_ before filling in the corresponding trace entry. Thus reading the new value of cur_offset_ doesn\u0027t guarantee anything about the preceding data being up-to-date.\n\nThus the high-level question here in my mind is whether cur_offset_ needs to be atomic at all.\n\nIt would be great to document the overall synchronization scheme here.",
      "range": {
        "startLine": 359,
        "startChar": 2,
        "endLine": 359,
        "endChar": 25
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e4d7edd_7cb37402",
        "filename": "runtime/trace.h",
        "patchSetId": 3
      },
      "lineNbr": 359,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2018-03-26T19:01:20Z",
      "side": 1,
      "message": "I\u0027m responsible for the bad overload, but please don\u0027t read it wrong.\n\ncur_offset_ is important for non-streaming mode. In that case, it is used to *allocate* a buffer chunk, not to synchronize reading it. \"Reading\" is done at the end, when a trace is actually written out. It\u0027s an old optimization, as writing traces *is* pretty much contended all the time - but nobody cares that the allocated data is up-to-date until the buffer has to be written out at the end.\n\nThe factoring with the streaming lock (in which case it is synchronizing because write-out can happen at any time) is crap, but it\u0027s hard to make it better w/o lots of code duplication.",
      "parentUuid": "fd8d968c_7b5618bc",
      "range": {
        "startLine": 359,
        "startChar": 2,
        "endLine": 359,
        "endChar": 25
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2221034_ada1cb5f",
        "filename": "runtime/trace.h",
        "patchSetId": 3
      },
      "lineNbr": 359,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-26T21:36:32Z",
      "side": 1,
      "message": "So if I call Stop(), it\u0027s the ScopedSuspendAll that guarantees that I will see a consistent state with no half-written entries?\n\nSo it seems to me that cur_offset_ is used exclusively to reserve buffer space. Suitable comment suggested above. Please correct if it looks like I\u0027m still missing something.",
      "parentUuid": "0e4d7edd_7cb37402",
      "range": {
        "startLine": 359,
        "startChar": 2,
        "endLine": 359,
        "endChar": 25
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11f32285_e6dbc2ca",
        "filename": "runtime/trace.h",
        "patchSetId": 3
      },
      "lineNbr": 359,
      "author": {
        "id": 1071150
      },
      "writtenOn": "2018-03-27T15:03:31Z",
      "side": 1,
      "message": "Yes, the paths through Stop() appear to provide the required consistency enforcement, but it\u0027s a little cryptic.\n\nPS5 adds GUARDED_BY annotations to seen_methods_ and seen_threads_ which are streaming related fields.\n\nThis is expensive code. The trade-off between the effort in abstraction and legibility seems awry.",
      "parentUuid": "a2221034_ada1cb5f",
      "range": {
        "startLine": 359,
        "startChar": 2,
        "endLine": 359,
        "endChar": 25
      },
      "revId": "d3981384dd82b308e700ae3c416620d35508a58f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}