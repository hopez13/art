{
  "comments": [
    {
      "key": {
        "uuid": "7b976875_a6b52265",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2018-07-11T01:58:10Z",
      "side": 1,
      "message": "HNullCheck",
      "range": {
        "startLine": 58,
        "startChar": 68,
        "endLine": 58,
        "endChar": 79
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fab91bdc_e14639b0",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2018-07-10T12:25:35Z",
      "side": 1,
      "message": "An alternative approach would be to\n\n  check-\u003eMarkEmittedAtUseSite();\n\nand replace the `next`\u0027s input with the `check`. Though we would have change codegen to hunt for the actual input for instructions that emit the implicit null check.",
      "range": {
        "startLine": 57,
        "startChar": 6,
        "endLine": 70,
        "endChar": 50
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "da05b5bd_461360c0",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-07-10T17:02:34Z",
      "side": 1,
      "message": "Good point. We would still need to copy the environment, but that will indeed avoid adding the flag in HInstruction. It will also make the CanThrow/NeedsEnvironment more than just boolean check.\n\nDo you have a strong preference for emitted at use site?",
      "parentUuid": "fab91bdc_e14639b0",
      "range": {
        "startLine": 57,
        "startChar": 6,
        "endLine": 70,
        "endChar": 50
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f35d8eb2_2a5667c6",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2018-07-11T01:58:10Z",
      "side": 1,
      "message": "I\u0027m ok with any of the two.",
      "parentUuid": "da05b5bd_461360c0",
      "range": {
        "startLine": 57,
        "startChar": 6,
        "endLine": 70,
        "endChar": 50
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28ffb5ed_e40d85f6",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2018-07-11T09:48:27Z",
      "side": 1,
      "message": "Why would we need to copy the environment? The environment shall still have locations allocated even if the check.IsEmittedAtUseSite() and we can use that environment to emit the stack map for the null check, right?\n\nAnd why would we need to change \"CanThrow/NeedsEnvironment\"? I\u0027d expect these to be unchanged, the check and the next keeping their own properties.\n\nI have a mild preference for the MarkEmittedAtUseSite() approach as I believe it will be cleaner. (If we do need to copy the environment or change CanThrow/NeedsEnvironment, this may not be the case.)",
      "parentUuid": "f35d8eb2_2a5667c6",
      "range": {
        "startLine": 57,
        "startChar": 6,
        "endLine": 70,
        "endChar": 50
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a627fbd_c663cf67",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-07-11T13:18:54Z",
      "side": 1,
      "message": "Even with keeping the HNullCheck in the graph, we still need to copy the environment, as register allocators can insert HParallelMove between the null check and its first user (which is what this CL is fixing).",
      "parentUuid": "28ffb5ed_e40d85f6",
      "range": {
        "startLine": 57,
        "startChar": 6,
        "endLine": 70,
        "endChar": 50
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d91d29e_6ca99e1d",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2018-07-11T13:39:52Z",
      "side": 1,
      "message": "Than it\u0027s the register allocator that needs fixing to respect \"emitted at use site\".",
      "parentUuid": "3a627fbd_c663cf67",
      "range": {
        "startLine": 57,
        "startChar": 6,
        "endLine": 70,
        "endChar": 50
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf68378b_f26fa060",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-07-11T13:52:30Z",
      "side": 1,
      "message": "The \"emitted at use site\" right now is only for materialization of the instruction. Implicit HNullCheck never materialized so didn\u0027t need the null check.\n\nWhat would be required for not having HParallelMove between a \"generate at use site\" instruction and its user, is to special case the instruction to not have a liveness range. I\u0027d really want to avoid special cases in the register allocator.",
      "parentUuid": "7d91d29e_6ca99e1d",
      "range": {
        "startLine": 57,
        "startChar": 6,
        "endLine": 70,
        "endChar": 50
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6239bbd6_bbe2e602",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2018-07-11T14:51:19Z",
      "side": 1,
      "message": "One reason for doing it is the explicit null check forced by lines 64-66.\n\nLooking at the callers of HInstruction::IsEmittedAtUseSite(), I didn\u0027t find the register allocator. I found only SsaLivenessAnalysis and especially SsaLivenessAnalysis::ComputeLiveRanges(). What if we just changed that one function to accept instructions \"emitted at use site\" with environments (drop a DCHECK())? It could simply pass the \"actual_user\" when creating environment uses.",
      "parentUuid": "cf68378b_f26fa060",
      "range": {
        "startLine": 57,
        "startChar": 6,
        "endLine": 70,
        "endChar": 50
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bbcc7d0_295110f0",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-07-11T21:05:59Z",
      "side": 1,
      "message": "I think this would special case again, which I\u0027m not a big fan of. Ideally those generated at use site instructions shouldn\u0027t need to be in the graph (they are overhead for the register allocator), so I would be tempted to say best way forward is to eventually remove the \"generated at use site\" special case.\n\nThe environment needs to be on the user, to ensure we have the right locations. Note that the TODO from Calin that I removed suggested an alternative solution, which is it analyze the HParallelMove to \"fix\" the stack maps. However, I think it\u0027s just more natural to have the environment used for NPE placed on the instruction that does the NPE check (and we don\u0027t need to emulate the moves in the stack maps).",
      "parentUuid": "6239bbd6_bbe2e602",
      "range": {
        "startLine": 57,
        "startChar": 6,
        "endLine": 70,
        "endChar": 50
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6ed11ddc_5266f67c",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2018-07-18T16:48:27Z",
      "side": 1,
      "message": "What I really don\u0027t like about this CL is the lines 64-66 that insert an extra load just because we cannot have 2 environments at the same lifetime position. This happens for every inlined instance method that calls another method on the inner `this` (unless the null check in outer method was eliminated).\n\nI think the \"emitted-at-use-site\" HIR is a neat way to avoid creating tons of fused HIR classes. And they do not add any overhead to the register allocator when you compare it with the theoretical merged HIR: there are the same locations and live ranges to process.",
      "parentUuid": "9bbcc7d0_295110f0",
      "range": {
        "startLine": 57,
        "startChar": 6,
        "endLine": 70,
        "endChar": 50
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51f9d283_c5bfb015",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 2
      },
      "lineNbr": 3933,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2018-07-11T14:51:19Z",
      "side": 1,
      "message": "Why only x86 and not x86-64? (And in the future maybe also arm64 host builds.)",
      "range": {
        "startLine": 3933,
        "startChar": 42,
        "endLine": 3933,
        "endChar": 77
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6accb270_6747bc8b",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 2
      },
      "lineNbr": 3933,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-07-11T21:05:59Z",
      "side": 1,
      "message": "The bug is only on x86. On x86-64, libunwind code works.",
      "parentUuid": "51f9d283_c5bfb015",
      "range": {
        "startLine": 3933,
        "startChar": 42,
        "endLine": 3933,
        "endChar": 77
      },
      "revId": "f6b0f038d5910dc5df8c016116887c01b950525d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}