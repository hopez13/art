{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "3e10c966_8eea304f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1894735
      },
      "writtenOn": "2023-11-10T14:50:49Z",
      "side": 1,
      "message": "Hanks and Lokesh, this is the CL I was mentioning in our meeting yesterday. If it makes sense I will land this just to document why we need it there. There was discussion about a stress test for this. I will try to take a look and add a test. I guess if we no longer release mutator lock in GC this may not happen but IIUC, I think we still release it in some cases even if it is for a short period right.",
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "155edafc_1022efef",
        "filename": "openjdkjvmti/deopt_manager.cc",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2022-10-07T19:59:44Z",
      "side": 1,
      "message": "Does this happen as part of SuspendAll below? This itself guarantees that a GC cannot happen concurrently. So I\u0027m not sure why is GC critical section required here.",
      "range": {
        "startLine": 331,
        "startChar": 16,
        "endLine": 331,
        "endChar": 50
      },
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ae9a161_c6f2a34f",
        "filename": "openjdkjvmti/deopt_manager.cc",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 1894735
      },
      "writtenOn": "2022-10-10T08:37:43Z",
      "side": 1,
      "message": "Yes, that\u0027s a part of SuspendAll. Visiting class loaders is also in SuspendAll scope. From the original bug that introduced this GCCriticalSection (CL: aosp/836451, bug: b/113777552) it appears that there could be a GC in progress and still succeed in SuspendAll. It was a while back though (from 2018).  From the original bug:\n\n* HeapTaskDaemon waits for mutator_lock_: which exclusive held by\nAndroidJUnitRunner.\n*       AndroidJUnitRunner WaitHoldingLocks on\nConditionVariable(weak_globals_add_condition_) which HeapTaskDaemon\nwill do a broadcast.\n\nHeapTaskDaemon:\n\n#0  syscall () at bionic/libc/arch-arm/bionic/syscall.S:44\n#1  0xa59a8606 in art::futex (uaddr\u003d\u003coptimized out\u003e, op\u003d0, val\u003d-1,\ntimeout\u003d\u003coptimized out\u003e, uaddr2\u003d\u003coptimized out\u003e, val3\u003d0)\n   at art/runtime/base/mutex-inl.h:43\n#2  art::ReaderWriterMutex::HandleSharedLockContention\n(this\u003d0xa580e000, self\u003d0x9fe33000, cur_state\u003d-1)\n    at art/runtime/base/mutex.cc:771\n#3  0xa5a5a500 in art::ReaderWriterMutex::SharedLock (this\u003d0xa580e000,\nself\u003d\u003coptimized out\u003e)\n    at art/runtime/base/mutex-inl.h:169\n#4  art::gc::collector::ConcurrentCopying::IssueEmptyCheckpoint\n(this\u003d\u003coptimized out\u003e)\n    at art/runtime/gc/collector/concurrent_copying.cc:1056\n#5  0xa5a5d644 in\nart::gc::collector::ConcurrentCopying::ProcessMarkStackOnce\n(this\u003d0xa5db6a80)\n    at art/runtime/gc/collector/concurrent_copying.cc:1430\n#6  0xa5a5d5d8 in\nart::gc::collector::ConcurrentCopying::ProcessMarkStack\n(this\u003d0xa5db6a80)\n\nAndroidJUnitRunner:\n#2  art::ConditionVariable::WaitHoldingLocks (this\u003d0xa5dcb1ac,\nself\u003d0x9fe3e000) at art/runtime/base/mutex.cc:953\n#3  0xa5b35ae4 in art::JavaVMExt::DecodeWeakGlobalLocked\n(this\u003d0xa5dcb140, self\u003d0x9fe3e000, ref\u003d\u003coptimized out\u003e)\n    at art/runtime/java_vm_ext.cc:799\n#4  0xa5b35a56 in art::JavaVMExt::DecodeWeakGlobal (this\u003d0xa5dcb140,\nself\u003d0x9fe3e000, ref\u003d\u003coptimized out\u003e)\n    at art/runtime/java_vm_ext.cc:788\n#5  0xa5c753a0 in art::Thread::DecodeJObject (this\u003d0x9fe3e000,\nobj\u003d0x187) at art/runtime/thread.cc:2387\n#6  0xa59db902 in art::ClassLinker::VisitClassLoaders (this\u003d\u003coptimized\nout\u003e, visitor\u003d\u003coptimized out\u003e)\n\n\n\nIf things have changed and we do guarantee there is no GC in progress then we can drop this.",
      "parentUuid": "155edafc_1022efef",
      "range": {
        "startLine": 331,
        "startChar": 16,
        "endLine": 331,
        "endChar": 50
      },
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "892a5f26_a7b1048d",
        "filename": "openjdkjvmti/deopt_manager.cc",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2022-10-10T17:26:35Z",
      "side": 1,
      "message": "Now I recall that there are a bunch of places where the GC has to release the muator_lock_, notably when wanting to issue a checkpoint, which gives an opportunity to other threads to suspend-all, if needed.\n\n@hboehm@google.com, this is why I was saying that it would be actually good if we could make it mandatory for issuing checkpoints to require mutator_lock_ being held in shared mode.\n\nAnother thing that will help would if we could allow lowering mutator_lock_ from exclusive to shared mode, without releasing it.",
      "parentUuid": "2ae9a161_c6f2a34f",
      "range": {
        "startLine": 331,
        "startChar": 16,
        "endLine": 331,
        "endChar": 50
      },
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47531dc4_5f806c99",
        "filename": "openjdkjvmti/deopt_manager.cc",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-10-10T22:31:31Z",
      "side": 1,
      "message": "My current CL doesn\u0027t specify whether RunCheckpoint holds the mmutator lock because it appears there is an easier way to solve my problems by making sure Run methods don\u0027t suspend. (Which seems to be almost true.) That change also seems a little tricky because there is at least one non-GC caller that doesn\u0027t specify whether it holds the mutator lock. Independently, that may still be a good change, though.\n\nI looked a little bit at adding lock downgrades. I think it would be more painful to provide that facility than I thought. I still think that our futex-based implementation could provide it. But on some non-Android platforms, we rely on pthread_rwlock, which doesn\u0027t. And I believe it\u0027s specified as writer-preference, which may make the semantics slightly controversial, though I don\u0027t see any showstopper issues.\n\nI wonder whether that old deadlock is still real. Some of this code has changed. HeapTaskDaemon was trying to run an empty checkpoint. Whenever we wait for weak globals, we first wait for empty checkpoint requests. And the theory is that if there aren\u0027t any, and we\u0027re processing references, then we will issue no more such requests before finishing reference processing.\n\nDo we have something like a deopt stress test? Can we try removing the GC critical section? If nothing else, a more recent set of stack traces for the deadlock would be helpful.",
      "parentUuid": "892a5f26_a7b1048d",
      "range": {
        "startLine": 331,
        "startChar": 16,
        "endLine": 331,
        "endChar": 50
      },
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db2e2a84_e46e6f7a",
        "filename": "openjdkjvmti/deopt_manager.cc",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 1894735
      },
      "writtenOn": "2022-10-11T13:21:36Z",
      "side": 1,
      "message": "Thanks Lokesh and Hans! \n\nI am not sure I understand it fully. Why don\u0027t we expect a deadlock now? Is it because when GC releases the mutator_lock_ and thereby allowing us to enter SuspendAll scope with exclusive mutator_lock we should be able to decode weak reference and not block on GC anymore? \n\nI tried to look for a stress test for this case. I think deopt stress test maynot stress this part because this is only for jvmti. There are some jvmti-stress options for field access and field modification but they just enable the feature once, so we will hit this path only once. We should constantly enable / disable these feature or keep setting breakpoints to stress this. I couldn\u0027t find such a test but happy to look into this and add a test and remove this critical section to see if we have any failures.",
      "parentUuid": "47531dc4_5f806c99",
      "range": {
        "startLine": 331,
        "startChar": 16,
        "endLine": 331,
        "endChar": 50
      },
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da4bdabb_7061dab3",
        "filename": "openjdkjvmti/deopt_manager.cc",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-10-12T05:07:39Z",
      "side": 1,
      "message": "I see what you mean. I had misunderstood what\u0027s going on in the bug. The core issue here is that at some colder level in the AndroidJUnitRunner stack, we suspended all the other threads, and then do a weak reference access that waits for another thread, which happens to be the HeapTaskDaemon, which can\u0027t progress. Let me think about this more tomorrow.",
      "parentUuid": "db2e2a84_e46e6f7a",
      "range": {
        "startLine": 331,
        "startChar": 16,
        "endLine": 331,
        "endChar": 50
      },
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}