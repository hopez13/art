// Copyright 2019 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package art

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/google/blueprint"
	"github.com/google/blueprint/proptools"

	"android/soong/android"
	"android/soong/java"
)

// Rules to build a smaller "core" image to support core libraries
// (that is, non-Android frameworks) testing on the host and target
//
// The main rules to build the default "boot" image are in
// build/soong/java/dexpreopt_bootjars.go
// TODO(ccross): these rules should be combined with the ones in dexpreopt_bootjars.go

// Modules to compile for core.art.
var coreImageJars = []string{
	"core-oj",
	"core-libart",
	"okhttp",
	"bouncycastle",
	"apache-xml",
}

const testDir = "art-test"

func init() {
	android.RegisterModuleType("art_image", imageFactory)
	android.RegisterSingletonType("art_image_singleton", imageSingletonFactory)
}

func imageFactory() android.Module {
	module := &image{}

	module.AddProperties(&module.properties)
	android.AddLoadHook(module, prefer32Bit)
	android.InitAndroidArchModule(module, android.HostAndDeviceDefault, android.MultilibBoth)

	return module
}

type image struct {
	android.ModuleBase
	properties imageProperties

	installPath android.Path
	name        string
	artLocation string
}

type imageProperties struct {
	Compiler *string
	Flags    []string
	Suffix   *string
	Image    *string
}

func (i *image) DepsMutator(ctx android.BottomUpMutatorContext) {
	bootclasspath := android.CopyOf(coreImageJars)

	if !ctx.Host() {
		for i := range bootclasspath {
			bootclasspath[i] += "-testdex"
		}
	}

	ctx.AddFarVariationDependencies([]blueprint.Variation{
		{Mutator: "arch", Variation: "android_common"},
	}, imageBootclasspathDepTag, bootclasspath...)
}

func (i *image) GenerateAndroidBuildActions(ctx android.ModuleContext) {
	global := java.DexpreoptGlobalConfig(ctx)

	// outputDir is the intermediate directory into which the image will be built before installing to the final
	// location.
	outputDir := android.PathForModuleOut(ctx, "system/framework", ctx.Arch().ArchType.String())
	imageName := "core" + proptools.String(i.properties.Suffix)
	outputPath := outputDir.Join(ctx, imageName+".art")

	oatPath := outputPath.ReplaceExtension(ctx, "oat")

	// locationDir is the path that the image will be found at after installation.  For the host it is the
	// host install directory, for the device it is the on-device path.
	var locationDir string
	if ctx.Host() {
		locationDir = android.PathForModuleInstall(ctx, "framework").String()
	} else {
		locationDir = "/system/framework"
	}

	oatLocation := filepath.Join(locationDir, ctx.Arch().ArchType.String(), oatPath.Base())
	artLocation := filepath.Join(locationDir, ctx.Arch().ArchType.String(), outputPath.Base())

	// Collect paths and on-device locations of the bootclasspath jars.
	var dexPaths android.Paths
	var dexLocations []string
	for _, dep := range ctx.GetDirectDepsWithTag(imageBootclasspathDepTag) {
		if j, ok := dep.(interface{ DexJar() android.Path }); ok {
			dexPaths = append(dexPaths, j.DexJar())
			if ctx.Host() {
				dexLocations = append(dexLocations, filepath.Join(locationDir, ctx.OtherModuleName(dep)+"-hostdex.jar"))
			} else {
				dexLocations = append(dexLocations, filepath.Join(locationDir, ctx.OtherModuleName(dep)+".jar"))
			}
		} else {
			ctx.PropertyErrorf("bootclasspath", "bootclasspath module %q not a DexJar producer",
				ctx.OtherModuleName(dep))
		}
	}

	// Determine the extra files that will be generated by dex2oat to use as ImplicitOutputs and to generate
	// install rules.  This logic must match dex2oat's logic for converting bootclasspath paths to output paths.
	var extraFiles android.WritablePaths
	for i, m := range dexLocations {
		name := imageName
		if i != 0 {
			name += "-" + strings.TrimSuffix(filepath.Base(m), ".jar")
		}

		for _, ext := range []string{".art", ".oat", ".vdex"} {
			extraFiles = append(extraFiles, outputDir.Join(ctx, name+ext))
		}
	}
	// Skip the first file, which will be "core.art", that will be used as the main output.
	if w, g := outputPath.String(), extraFiles[0].String(); w != g {
		panic(fmt.Errorf("expected first dex2oat file to be %q, got %q", w, g))
	}
	extraFiles = extraFiles[1:]

	var instructionSetFeatures string
	if ctx.Host() {
		instructionSetFeatures2nd := ""
		if targetIsPrimary(ctx, ctx.Target()) {
			instructionSetFeatures2nd = "2ND_"
		}
		instructionSetFeaturesVar := instructionSetFeatures2nd + "DEX2OAT_HOST_INSTRUCTION_SET_FEATURES_OPTION"
		instructionSetFeatures = ctx.Config().GetenvWithDefault(instructionSetFeaturesVar, "default")
	} else {
		instructionSetFeatures = global.InstructionSetFeatures[ctx.Target().Arch.ArchType]
	}

	rule := android.NewRuleBuilder()

	rule.Command().Text("rm").Flag("-f").
		Flag(outputDir.Join(ctx, "*.art").String()).
		Flag(outputDir.Join(ctx, "*.oat").String()).
		Flag(outputDir.Join(ctx, "*.invocation").String())

	cmd := rule.Command()

	// Use ANDROID_LOG_TAGS to suppress most logging by default...
	cmd.Text(`ANDROID_LOG_TAGS="*:e"`)

	cmd.Tool(global.Tools.Dex2oat).
		Flag("--avoid-storing-invocation").
		Flag("--runtime-arg").FlagWithArg("-Xms", global.Dex2oatImageXms).
		Flag("--runtime-arg").FlagWithArg("-Xmx", global.Dex2oatImageXmx)

	cmd.
		FlagForEachInput("--dex-file=", dexPaths).
		FlagForEachArg("--dex-location=", dexLocations).
		Flag("--generate-debug-info").
		Flag("--generate-build-id").
		FlagWithOutput("--oat-file=", oatPath).
		FlagWithArg("--oat-location=", oatLocation).
		FlagWithOutput("--image=", outputPath).
		ImplicitOutputs(extraFiles).
		FlagWithArg("--base=", ctx.Config().LibartImgHostBaseAddress()).
		FlagWithArg("--instruction-set=", ctx.Arch().ArchType.String()).
		FlagWithArg("--instruction-set-variant=", ctx.Arch().CpuVariant).
		FlagWithArg("--instruction-set-features=", instructionSetFeatures).
		FlagWithArg("--android-root=", global.EmptyDirectory).
		FlagWithArg("--no-inline-from=", "core-oj.jar").
		FlagWithArg("--runtime-arg ", "-XX:SlowDebug=true").
		Flags(i.properties.Flags)

	if ctx.Host() {
		cmd.Flag("--host")
	}

	cmd.Text("|| rm ").Output(outputPath)

	rule.Build(pctx, ctx, "dex2oat", "dex2oat")

	var installDir string
	if ctx.Host() {
		installDir = "framework"
	} else {
		installDir = testDir
	}

	installPath := android.PathForModuleInstall(ctx, installDir, ctx.Arch().ArchType.String())

	// Install all the extra files and use their installed path as a dependency of the main output file.
	var installDeps android.Paths
	for _, f := range extraFiles {
		installDeps = append(installDeps, ctx.InstallFile(installPath, f.Base(), f))
	}

	if ctx.Host() {
		for _, f := range dexLocations {
			installDeps = append(installDeps,
				android.PathForModuleInstall(ctx, "framework", filepath.Base(f)))
		}
	}

	i.installPath = ctx.InstallFile(installPath, imageName+".art", outputPath, installDeps...)
	i.name = proptools.String(i.properties.Image)
	i.artLocation = artLocation
}

func (i *image) InstallInData() bool {
	return true
}

func (i *image) InstallBypassMake() bool {
	// Tell Soong to generate install rules that install directly to out/ instead of out/soong/, these modules are
	// not passed to Make's base_rules.mk.
	return true
}

type imageDependencyTag struct {
	blueprint.DependencyTag
	name string
}

var imageBootclasspathDepTag = imageDependencyTag{name: "bootclasspath"}

func imageSingletonFactory() android.Singleton {
	return &imageSingleton{}
}

type imagePaths struct {
	all     android.Paths
	names   []string
	bitness []string
	def     android.Path
}

// imageSingleton collects the install paths of the various images for producing Make variables for use by remaining art
// makefiles.
type imageSingleton struct {
	host, device imagePaths
}

func (is *imageSingleton) GenerateBuildActions(ctx android.SingletonContext) {
	ctx.VisitAllModules(func(m android.Module) {
		if image, ok := m.(*image); ok {
			var imagePaths *imagePaths
			if image.Target().Os.Class == android.Host {
				imagePaths = &is.host
			} else {
				imagePaths = &is.device
			}

			imagePaths.all = append(imagePaths.all, image.installPath)
			imagePaths.names = append(imagePaths.names, image.name)
			imagePaths.bitness = append(imagePaths.bitness, strings.TrimPrefix(image.Target().Arch.ArchType.Multilib, "lib"))

			if proptools.String(image.properties.Suffix) == "" {
				imagePaths.def = image.installPath
			}
		}
	})
}

func (is *imageSingleton) MakeVars(ctx android.MakeVarsContext) {
	var host, device android.Paths
	ctx.VisitAllModules(func(m android.Module) {
		if image, ok := m.(*image); ok {
			if !image.Enabled() {
				return
			}

			// TODO(ccross): remove when TARGET_TRANSLATE_2ND_ARCH is removed in favor of native bridge, which already
			//  filters the native bridge arch out of MultilibBoth.
			if !targetIsPrimary(ctx, image.Target()) && ctx.Config().SecondArchIsTranslated() {
				return
			}

			var prefix string
			if image.Target().Os.Class == android.Host {
				host = append(host, image.installPath)
				prefix = "HOST_"
			} else {
				device = append(device, image.installPath)
				prefix = "TARGET_"
			}

			// Using the bitness suffix makes it easier to add as a dependency for the run-test mk.
			bitness := strings.TrimPrefix(image.Target().Arch.ArchType.Multilib, "lib")
			ctx.Strict(prefix+"CORE_IMAGE_"+image.name+"_"+bitness, image.installPath.String())

			// Define a default core image that can be used for things like gtests that
			// need some image to run, but don't otherwise care which image is used.
			if image.name == "optimizing" {
				ctx.Strict(prefix+"CORE_IMAGE_DEFAULT_"+bitness, image.installPath.String())
				if targetIsPrimary(ctx, image.Target()) {
					// Oat location of core.art.
					ctx.Strict(prefix+"CORE_IMG_LOCATION", image.artLocation)

					// core.art locations under the out directory.
					ctx.Strict(prefix+"CORE_IMG_OUT_BASE", strings.TrimSuffix(image.installPath.String(), ".art"))
				}
			}
		}
	})

	ctx.Strict("HOST_CORE_IMG_OUTS", strings.Join(host.Strings(), " "))
	ctx.Strict("TARGET_CORE_IMG_OUTS", strings.Join(device.Strings(), " "))

	ctx.Strict("CORE_IMG_JARS", strings.Join(coreImageJars, " "))

	// Directory used for oat tests on device.
	ctx.Strict("ART_TARGET_TEST_DIR", filepath.Join("/data", testDir))
}

func targetIsPrimary(ctx android.PathContext, target android.Target) bool {
	return target.Arch.ArchType == ctx.Config().Targets[target.Os][0].Arch.ArchType
}
