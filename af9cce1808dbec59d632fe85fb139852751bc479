{
  "comments": [
    {
      "key": {
        "uuid": "dcb984a9_00e9eee2",
        "filename": "runtime/gc/collector/concurrent_copying.h",
        "patchSetId": 5
      },
      "lineNbr": 377,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-12-03T03:13:28Z",
      "side": 1,
      "message": "This may be a question for Lokesh as well:\n\nThis is basically what might traditionally be called the average cons to mark ratio.\n\nIs this really the mathematically correct metric? It seems to give the same weight to what happens in small heap/cheap GCs as it does to collections that happen when the heap is much larger. To me it seems that sum(reclaimed_bytes)/sum(allocated_bytes at GC end) or the inverse (i.e. the total mark to cons ratio) would be a better choice. Effectively that gives larger collections the weight they deserve.",
      "range": {
        "startLine": 377,
        "startChar": 2,
        "endLine": 377,
        "endChar": 35
      },
      "revId": "af9cce1808dbec59d632fe85fb139852751bc479",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bab1c47_b242f55e",
        "filename": "runtime/gc/collector/concurrent_copying.h",
        "patchSetId": 5
      },
      "lineNbr": 377,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2018-12-03T20:08:56Z",
      "side": 1,
      "message": "Just to confirm, are you suggesting that we should use bytes allocated after GC and not before for computing the ratio?\n\nOn another thought, instead of having a reclaimed bytes ratio over the bytes allocated of the entire heap, shouldn\u0027t it be over just the regions covered in that type of GC? That will give us an indication of whether generational hypothesis holds for us or not. If it holds, then we can expect to see a larger ratio for young GCs than full GCs. In the current form, I\u0027m not sure if it gives any additional insight than what a simple metric like \"avg bytes freed\" would give.",
      "parentUuid": "dcb984a9_00e9eee2",
      "range": {
        "startLine": 377,
        "startChar": 2,
        "endLine": 377,
        "endChar": 35
      },
      "revId": "af9cce1808dbec59d632fe85fb139852751bc479",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f6d4f0a_706eecad",
        "filename": "runtime/gc/collector/concurrent_copying.h",
        "patchSetId": 5
      },
      "lineNbr": 377,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-12-03T22:05:09Z",
      "side": 1,
      "message": "I\u0027d argue for yes to all of the above, though those are slightly different issues. But this is clearly a question about what we\u0027re trying to measure.\n\nThe reason I initially thought this is weird is that computing the arithmetic mean of ratios is generally wrong. That\u0027s also how you demonstrate that your great new optimization that speeds up your code by a factor of 10 half the time, and slows it down by a factor of 10 the other half, is a great win, because it results in a mean speedup of around 5. (That has been done in academic papers, but ...) That\u0027s not exactly the problem here, but it remains fishy.",
      "parentUuid": "9bab1c47_b242f55e",
      "range": {
        "startLine": 377,
        "startChar": 2,
        "endLine": 377,
        "endChar": 35
      },
      "revId": "af9cce1808dbec59d632fe85fb139852751bc479",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd601204_c6f90aac",
        "filename": "runtime/gc/collector/concurrent_copying.h",
        "patchSetId": 5
      },
      "lineNbr": 425,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-12-03T03:13:28Z",
      "side": 1,
      "message": "Why is this signed? The comment specifies a good reason to cast it to signed before performing the subtraction. But the value itself seems clearly non-negative. I believe the usual convention in this code is to use size_t for such things. I have a pending CL that makes it a bit more consistent that way.",
      "range": {
        "startLine": 425,
        "startChar": 2,
        "endLine": 425,
        "endChar": 41
      },
      "revId": "af9cce1808dbec59d632fe85fb139852751bc479",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}